{
  
    
  
    
  
    
        "post2": {
            "title": "ML in Cheminformatics (Reviews and Prospectives)",
            "content": "General . Artificial intelligence in drug discovery: what is realistic, what are illusions? Part 2: a discussion of chemical and biological data (Drug Discovery Today 2021) . | Artificial intelligence in drug discovery: what is realistic, what are illusions? Part 1: Ways to make an impact, and why we are not there yet (Drug Discovery Today 2020) . | Data-Driven Strategies for Accelerated Materials Design (Accounts of Chemical Rrsearch 2021) . | The Role of Machine Learning in the Understanding and Design of Materials (JACS 2020) . | Rethinking drug design in the artificial intelligence era (Nature Reviews Drug Discovery 2020) . | Chemists: AI Is Here; Unite To Get the Benefit (J Med Chem 2020) . | Drug discovery with explainable artificial intelligence (Nature Machine Intelligence 2020) . | Machine learning approaches to drug response prediction: challenges and recent progress (Precision Oncology 2020) . | Machine learning and AI-based approaches for bioactive ligand discovery and GPCR-ligand recognition (Methods 2020) . | Towards reproducible computational drug discovery (J Cheminformatics 2020) . | Current and Future Roles of Artificial Intelligence in Medicinal Chemistry Synthesis (J Med Chem 2020) . | Drug Research Meets Network Science: Where Are We? (J Med Chem 2020) . | Chemist versus Machine: Traditional Knowledge versus Machine Learning Techniques (Trends in Chemistry30265-3) 2020) . | Current Trends, Overlooked Issues, and Unmet Challenges in Virtual Screening (JCIM 2020) . | What Will Computational Modeling Approaches Have to Say in the Era of Atomistic Cryo-EM Data? (JCIM 2020) . | Deep Learning in Chemistry (JCIM 2019) . | Deep learning in drug discovery: opportunities, challenges and future prospects (Drug Discovery Today 2019) . | Recent applications of deep learning and machine intelligence on in silico drug discovery: methods, tools and databases (Briefings in Bioinformatics 2019) . | Practical considerations for active machine learning in drug discovery (Drug Discovery Today 2019) . | Concepts of Artificial Intelligence for Computer-Assisted Drug Discovery (Chemical Review 2019) . | Machine learning in chemoinformatics and drug discovery (Drug Discovery Today 2018) . | The rise of deep learning in drug discovery (Drug Discovery Today 2018) . | Deep learning for computational chemistry (J Comp Chem 2017) . | . Molecular Representation . Molecular representations in AI-driven drug discovery: a review and practical guide (J Cheminformatics 2020） . | Cheminformatics in Natural Product-Based Drug Discovery (Molecular Informatics 2020) . | Exploring chemical space using natural language processing methodologies for drug discovery (Drug Discovery Today 2020) . | Molecular Representation: Going Long on Fingerprints (Chem30198-4) 2020) . | Learning Molecular Representations for Medicinal Chemistry (J Med Chem 2020) . | . QSAR/Target Prediction . QSAR without borders. (Chemical Society Reviews 2020) . | Bayer’s in silico ADMET platform: a journey of machine learning over the past two decades (Drug Discovery Today 2020) . | A compact review of molecular property prediction with graph neural networks (Drug Discovery Today 2020) . | Transfer Learning for Drug Discovery (J Med Chem 2020) . | Advances in exploring activity cliffs (J Computer-Aided Molecular Design 2020) . | Molecular property prediction: recent trends in the era of artificial intelligence (Drug Discovery Today 2019) . | Drug repurposing: a promising tool to accelerate the drug discovery process (Drug Discovery Today 2019) . | Advances and Challenges in Computational Target Prediction (JCIM 2019) . | ADMET modeling approaches in drug discovery (Drug Discovery Today 2019) . | A Survey of Multi‐task Learning Methods in Chemoinformatics (Mol Informatics 2018) . | Transfer and Multi-task Learning in QSAR Modeling: Advances and Challenges (Frontiers in Pharmacology 2018) . | . Model Interpretation/Uncertainty Estimation . Uncertainty quantification in drug design (Drug Discovery Today 2020) . | Predicting With Confidence: Using Conformal Prediction in Drug Discovery (J Pham Sci30589-X/fulltext) 2020) . | Interpretable Deep Learning in Drug Discovery (Preprint 2019) . | Concepts and Applications of Conformal Prediction in Computational Drug Discovery (Preprint 2019) . | . Chemical Reaction . Machine Learning in Computer-Aided Synthesis Planning (Accounts of Chemical Research 2018) | . Molecular modeling and simulation . Deep integration of machine learning into computational chemistry and materials science (Preprint 2021) . | Representations of molecules and materials for interpolation of quantum-mechanical simulations via machine learning (PrePrint 2020) . | Machine learning approaches for analyzing and enhancing molecular dynamics simulations (Current Opinion in Structural Biology 2020) . | Advances of machine learning in molecular modeling and simulation (Current Opinion in Chemical Engineering 2019) . | . Molecular Generation/Chemical Space . Peptides in chemical space (Med in Drug Discovery 2021) . | Defining and Exploring Chemical Spaces (Trends in Chemistry 2020) . | Deep Learning and Knowledge-Based Methods for Computer Aided Molecular Design -- Toward a Unified Approach: State-of-the-Art and Future Directions (Computers &amp; Chemical Engineering 2020) . | Virtual Compound Libraries in Computer-Assisted Drug Discovery (JCIM 2019) . | How to explore chemical space using algorithms and automation (Nature Reviews Chemistry 2019) . | Deep learning for molecular design—a review of the state of the art (Mol Systems Design &amp; Engineering 2019) . | Deep generative models for molecular science (Mol Informatics 2018) . | Conformation Generation: The State of the Art (JCIM 2017) . | Recent Advances in Scaffold Hopping (J Med Chem 2017) . | Active-learning strategies in computer-assisted drug discovery (Drug Discovery Today 2015) . | The quest for novel chemical matter and the contribution of computer-aided de novo design (Expert Opinion on Drug Discovery 2011) . | . Automation . Integrating Computational and Experimental Workflows for Accelerated Organic Materials Discovery (Advanced Materials 2021) . | Autonomous Discovery in the Chemical Sciences Part I: Progress (Angewandte Chemie 2019) . | Autonomous Discovery in the Chemical Sciences Part II: Outlook (Angewandte Chemie 2019) . | Automating drug discovery (Nature Reviews Drug Discovery 2017) . | . Beyond Chemistry . Deep Learning in Mining Biological Data (Cognitive Computation 2021) . | Informatics for Chemistry, Biology, and Biomedical Sciences (JCIM 2021) . | Image-based profiling for drug discovery: due for a machine-learning upgrade? (Nature Reviews Drug Discovery 2020) . | A review of optical chemical structure recognition tools (J Cheminformatics 2020) . | Deep Learning in Protein Structural Modeling and Design (Preprint 2020) . | Deep learning: new computational modelling techniques for genomics (Nature Reviews Genetics 2019) . | Proteochemometrics – recent developments in bioactivity and selectivity modeling (Drug Discovery Today 2019) . | Opportunities and obstacles for deep learning in biology and medicine (J Royal Society Interface 2018) . | Deep Learning in Biomedical Data Science (Annual Reviews 2018) . | Deep learning for computational biology (Molecular Syntems Biology 2016) . | Polypharmacology modelling using proteochemometrics (PCM): recent methodological developments, applications to target families, and future prospects (MedChemComm 2015) . | . Reviews/Prospectives in Related Fields . Machine Learning on Graphs: A Model and Comprehensive Taxonomy . | Generalizing from a Few Examples: A Survey on Few-Shot Learning . | Meta-Learning in Neural Networks: A Survey . | Explainable Deep Learning:A Field Guide for the Uninitiated . | Pre-trained Models for Natural Language Processing: A Survey . | Machine Learning in Python: Main developments and technology trends in data science, machine learning, and artificial intelligence . | A Gentle Introduction to Deep Learning for Graphs . | A Survey on Multi-Task Learning . | Automated Machine Learning: State-of-The-Art and Open Challenges . | A Comprehensive Survey on Graph Neural Networks . | On the Robustness of Interpretability Methods . | .",
            "url": "https://xinhaoli74.github.io/blog/articles/2021/01/31/reviews-category.html",
            "relUrl": "/articles/2021/01/31/reviews-category.html",
            "date": " • Jan 31, 2021"
        }
        
    
  
    
  
    
        ,"post4": {
            "title": "My RDKit Cheatsheet",
            "content": "Setup . The RDKit pacakge only supports conda installation. . !conda install -c rdkit rdkit -y . Install Conda and RDKit in Google Colab: . !wget -c https://repo.continuum.io/miniconda/Miniconda3-py37_4.8.3-Linux-x86_64.sh !chmod +x Miniconda3-py37_4.8.3-Linux-x86_64.sh !time bash ./Miniconda3-py37_4.8.3-Linux-x86_64.sh -b -f -p /usr/local !time conda install -c rdkit rdkit -y import sys sys.path.append(&#39;/usr/local/lib/python3.7/site-packages/&#39;) . Basic . import rdkit from rdkit import Chem from rdkit.Chem import AllChem from rdkit.Chem import Draw from rdkit.Chem.Draw import IPythonConsole rdkit.__version__ . &#39;2020.09.1&#39; . Chem vs. AllChem . As mentioned in the Getting Started: . The majority of “basic” chemical functionality (e.g. reading/writing molecules, substructure searching, molecular cleanup, etc.) is in the rdkit.Chem module. More advanced, or less frequently used, functionality is in rdkit.Chem.AllChem. . If you find the Chem/AllChem thing annoying or confusing, you can use python’s “import … as …” syntax to remove the irritation:python from rdkit.Chem import AllChem as Chem . Get a RDKit molecule from SMILES. RDKit molecule enable several features to handle molecules: drawing, computing fingerprints/properties, molecular curation etc. . smiles = &#39;COC(=O)c1c[nH]c2cc(OC(C)C)c(OC(C)C)cc2c1=O&#39; mol = Chem.MolFromSmiles(smiles) print(mol) . &lt;rdkit.Chem.rdchem.Mol object at 0x7ff9f4f04e90&gt; . The RDKit molecules can be directly printed in jupyter enviroment. . mol . Convert a RDKit molecule to SMILES. . smi = Chem.MolToSmiles(mol) smi . &#39;COC(=O)c1c[nH]c2cc(OC(C)C)c(OC(C)C)cc2c1=O&#39; . Convert a RDKit molecule to InchiKey. . Chem.MolToInchiKey(mol) . &#39;VSIUFPQOEIKNCY-UHFFFAOYSA-N&#39; . Convert a RDKit molecule to coordinative representation (which can be stored in .sdf file). . mol_block = Chem.MolToMolBlock(mol) print(mol_block) . RDKit 2D 23 24 0 0 0 0 0 0 0 0999 V2000 5.2500 -1.2990 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.7500 -1.2990 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 3.0000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 3.7500 1.2990 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1.5000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7500 -1.2990 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.7500 -1.2990 0.0000 N 0 0 0 0 0 0 0 0 0 0 0 0 -1.5000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.0000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.7500 1.2990 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.2500 1.2990 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -6.0000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -7.5000 0.0000 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -5.2500 -1.2990 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.0000 2.5981 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.7500 3.8971 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 -3.0000 5.1962 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -3.7500 6.4952 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.5000 5.1962 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -1.5000 2.5981 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 -0.7500 1.2990 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 0.7500 1.2990 0.0000 C 0 0 0 0 0 0 0 0 0 0 0 0 1.5000 2.5981 0.0000 O 0 0 0 0 0 0 0 0 0 0 0 0 1 2 1 0 2 3 1 0 3 4 2 0 3 5 1 0 5 6 2 0 6 7 1 0 7 8 1 0 8 9 2 0 9 10 1 0 10 11 1 0 11 12 1 0 12 13 1 0 12 14 1 0 10 15 2 0 15 16 1 0 16 17 1 0 17 18 1 0 17 19 1 0 15 20 1 0 20 21 2 0 21 22 1 0 22 23 2 0 22 5 1 0 21 8 1 0 M END . . SMILES Canonicalization . Chem.MolToSmiles(Chem.MolFromSmiles(smi)) . &#39;COC(=O)c1c[nH]c2cc(OC(C)C)c(OC(C)C)cc2c1=O&#39; . Reading sets of molecules . Major types of molecular file formats: . .csv file that includes a column of SMILES. See PandasTools section. | .smi/.txt file that includes SMILES. Collect the SMILES as a list. The following code is an example to read a .smi file that contains one SMILES per line. | file_name = &#39;somedata.smi&#39; with open(file_name, &quot;r&quot;) as ins: smiles = [] for line in ins: smiles.append(line.split(&#39; n&#39;)[0]) print(&#39;# of SMILES:&#39;, len(smiles)) . .sdf file that includes atom coordinates. Reading molecules from .sdf file. Code Example | Draw molecules in Jupter environment . Print molecules in grid. . smiles = [ &#39;N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c1ccccc1&#39;, &#39;c1ccc2c(c1)ccc1c2ccc2c3ccccc3ccc21&#39;, &#39;C=C(C)C1Cc2c(ccc3c2OC2COc4cc(OC)c(OC)cc4C2C3=O)O1&#39;, &#39;ClC(Cl)=C(c1ccc(Cl)cc1)c1ccc(Cl)cc1&#39; ] mols = [Chem.MolFromSmiles(smi) for smi in smiles] . Draw.MolsToGridImage(mols, molsPerRow=2, subImgSize=(200, 200)) . Disable Error Message . from rdkit import RDLogger RDLogger.DisableLog(&#39;rdApp.*&#39;) . Structure Standardization . PandasTools . PandasTools enables using RDKit molecules as columns of a Pandas Dataframe. . import pandas as pd from rdkit.Chem import PandasTools . url = &#39;https://raw.githubusercontent.com/XinhaoLi74/molds/master/clean_data/ESOL.csv&#39; esol_data = pd.read_csv(url) esol_data.head(1) . smiles logSolubility . 0 N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c... | -0.77 | . Add ROMol to Pandas Dataframe. . PandasTools.AddMoleculeColumnToFrame(esol_data, smilesCol=&#39;smiles&#39;) esol_data.head(1) . smiles logSolubility ROMol . 0 N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c... | -0.77 | | . ROMol column stores rdchem.Mol object. . print(type(esol_data.ROMol[0])) . &lt;class &#39;rdkit.Chem.rdchem.Mol&#39;&gt; . Draw the structures in grid. . PandasTools.FrameToGridImage(esol_data.head(8), legendsCol=&quot;logSolubility&quot;, molsPerRow=4) . Adding new columns of properites use Pandas map method. . esol_data[&quot;n_Atoms&quot;] = esol_data[&#39;ROMol&#39;].map(lambda x: x.GetNumAtoms()) esol_data.head(1) . smiles logSolubility ROMol n_Atoms . 0 N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c... | -0.77 | | 32 | . Before saving the dataframe as csv file, it is recommanded to drop the ROMol column. . esol_data = esol_data.drop([&#39;ROMol&#39;], axis=1) esol_data.head(1) . smiles logSolubility n_Atoms . 0 N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c... | -0.77 | 32 | . Descriptors/Fingerprints . The RDKit has a variety of built-in functionality for generating molecular fingerprints/descriptors. A detialed description can be found here. . url = &#39;https://raw.githubusercontent.com/XinhaoLi74/molds/master/clean_data/ESOL.csv&#39; esol_data = pd.read_csv(url) PandasTools.AddMoleculeColumnToFrame(esol_data, smilesCol=&#39;smiles&#39;) esol_data.head(1) . smiles logSolubility ROMol . 0 N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c... | -0.77 | | . Morgan Fingerprint (ECFPx) . AllChem.GetMorganFingerprintAsBitVect Parameters: . radius: no default value, usually set 2 for similarity search and 3 for machine learning. | nBits: number of bits, default is 2048. 1024 is also widely used. | other parameterss are ususlly left to default | More examples can be found in this notebook from my previous work. . radius=3 nBits=1024 ECFP6 = [AllChem.GetMorganFingerprintAsBitVect(x,radius=radius, nBits=nBits) for x in esol_data[&#39;ROMol&#39;]] . ECFP6[0] . &lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect at 0x7ff9f686bd50&gt; . ECFP6 fingerprint for each molecule has 1024 bits. . len(ECFP6[0]) . 1024 . Save as a .csv file for futher use (e.g., machine learning). I usually save (1) SMILES as index and (2) each bit as a column to the csv file. . ecfp6_name = [f&#39;Bit_{i}&#39; for i in range(nBits)] ecfp6_bits = [list(l) for l in ECFP6] df_morgan = pd.DataFrame(ecfp6_bits, index = esol_data.smiles, columns=ecfp6_name) df_morgan.head(1) . Bit_0 Bit_1 Bit_2 Bit_3 Bit_4 Bit_5 Bit_6 Bit_7 Bit_8 Bit_9 ... Bit_1014 Bit_1015 Bit_1016 Bit_1017 Bit_1018 Bit_1019 Bit_1020 Bit_1021 Bit_1022 Bit_1023 . smiles . N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c1ccccc1 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | ... | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | . 1 rows × 1024 columns . . ECFP6 (Count version) . ECFP6_counts = [AllChem.GetHashedMorganFingerprint(m,radius=radius, nBits=nBits) for m in mols] print(ECFP6_counts[0]) print(len(list(ECFP6_counts[0]))) print(list(ECFP6_counts[0])) . &lt;rdkit.DataStructs.cDataStructs.UIntSparseIntVect object at 0x7ff9f686bcb0&gt; 1024 [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0, 0] . . MACCS Keys . from rdkit.Chem import MACCSkeys maccs_keys = [MACCSkeys.GenMACCSKeys(m) for m in mols] print(maccs_keys[0]) print(len(maccs_keys[0])) print(list(maccs_keys[0])) . &lt;rdkit.DataStructs.cDataStructs.ExplicitBitVect object at 0x7ff9f600cf30&gt; 167 [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0] . . Molecular Quantun Numbers (MQN) Descriptors . from rdkit.Chem import rdMolDescriptors mqn_ds = [rdMolDescriptors.MQNs_(m) for m in mols] print(len(mqn_ds[0])) print(mqn_ds[0]) . 42 [20, 0, 0, 0, 0, 0, 0, 1, 0, 9, 2, 32, 15, 0, 1, 15, 3, 0, 7, 23, 12, 7, 7, 0, 0, 8, 5, 1, 0, 7, 11, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0] . . RDKit 2D Descriptors . from rdkit.Chem import Descriptors desc_list = [n[0] for n in Descriptors._descList] print(len(desc_list)) print(desc_list) . 208 [&#39;MaxEStateIndex&#39;, &#39;MinEStateIndex&#39;, &#39;MaxAbsEStateIndex&#39;, &#39;MinAbsEStateIndex&#39;, &#39;qed&#39;, &#39;MolWt&#39;, &#39;HeavyAtomMolWt&#39;, &#39;ExactMolWt&#39;, &#39;NumValenceElectrons&#39;, &#39;NumRadicalElectrons&#39;, &#39;MaxPartialCharge&#39;, &#39;MinPartialCharge&#39;, &#39;MaxAbsPartialCharge&#39;, &#39;MinAbsPartialCharge&#39;, &#39;FpDensityMorgan1&#39;, &#39;FpDensityMorgan2&#39;, &#39;FpDensityMorgan3&#39;, &#39;BCUT2D_MWHI&#39;, &#39;BCUT2D_MWLOW&#39;, &#39;BCUT2D_CHGHI&#39;, &#39;BCUT2D_CHGLO&#39;, &#39;BCUT2D_LOGPHI&#39;, &#39;BCUT2D_LOGPLOW&#39;, &#39;BCUT2D_MRHI&#39;, &#39;BCUT2D_MRLOW&#39;, &#39;BalabanJ&#39;, &#39;BertzCT&#39;, &#39;Chi0&#39;, &#39;Chi0n&#39;, &#39;Chi0v&#39;, &#39;Chi1&#39;, &#39;Chi1n&#39;, &#39;Chi1v&#39;, &#39;Chi2n&#39;, &#39;Chi2v&#39;, &#39;Chi3n&#39;, &#39;Chi3v&#39;, &#39;Chi4n&#39;, &#39;Chi4v&#39;, &#39;HallKierAlpha&#39;, &#39;Ipc&#39;, &#39;Kappa1&#39;, &#39;Kappa2&#39;, &#39;Kappa3&#39;, &#39;LabuteASA&#39;, &#39;PEOE_VSA1&#39;, &#39;PEOE_VSA10&#39;, &#39;PEOE_VSA11&#39;, &#39;PEOE_VSA12&#39;, &#39;PEOE_VSA13&#39;, &#39;PEOE_VSA14&#39;, &#39;PEOE_VSA2&#39;, &#39;PEOE_VSA3&#39;, &#39;PEOE_VSA4&#39;, &#39;PEOE_VSA5&#39;, &#39;PEOE_VSA6&#39;, &#39;PEOE_VSA7&#39;, &#39;PEOE_VSA8&#39;, &#39;PEOE_VSA9&#39;, &#39;SMR_VSA1&#39;, &#39;SMR_VSA10&#39;, &#39;SMR_VSA2&#39;, &#39;SMR_VSA3&#39;, &#39;SMR_VSA4&#39;, &#39;SMR_VSA5&#39;, &#39;SMR_VSA6&#39;, &#39;SMR_VSA7&#39;, &#39;SMR_VSA8&#39;, &#39;SMR_VSA9&#39;, &#39;SlogP_VSA1&#39;, &#39;SlogP_VSA10&#39;, &#39;SlogP_VSA11&#39;, &#39;SlogP_VSA12&#39;, &#39;SlogP_VSA2&#39;, &#39;SlogP_VSA3&#39;, &#39;SlogP_VSA4&#39;, &#39;SlogP_VSA5&#39;, &#39;SlogP_VSA6&#39;, &#39;SlogP_VSA7&#39;, &#39;SlogP_VSA8&#39;, &#39;SlogP_VSA9&#39;, &#39;TPSA&#39;, &#39;EState_VSA1&#39;, &#39;EState_VSA10&#39;, &#39;EState_VSA11&#39;, &#39;EState_VSA2&#39;, &#39;EState_VSA3&#39;, &#39;EState_VSA4&#39;, &#39;EState_VSA5&#39;, &#39;EState_VSA6&#39;, &#39;EState_VSA7&#39;, &#39;EState_VSA8&#39;, &#39;EState_VSA9&#39;, &#39;VSA_EState1&#39;, &#39;VSA_EState10&#39;, &#39;VSA_EState2&#39;, &#39;VSA_EState3&#39;, &#39;VSA_EState4&#39;, &#39;VSA_EState5&#39;, &#39;VSA_EState6&#39;, &#39;VSA_EState7&#39;, &#39;VSA_EState8&#39;, &#39;VSA_EState9&#39;, &#39;FractionCSP3&#39;, &#39;HeavyAtomCount&#39;, &#39;NHOHCount&#39;, &#39;NOCount&#39;, &#39;NumAliphaticCarbocycles&#39;, &#39;NumAliphaticHeterocycles&#39;, &#39;NumAliphaticRings&#39;, &#39;NumAromaticCarbocycles&#39;, &#39;NumAromaticHeterocycles&#39;, &#39;NumAromaticRings&#39;, &#39;NumHAcceptors&#39;, &#39;NumHDonors&#39;, &#39;NumHeteroatoms&#39;, &#39;NumRotatableBonds&#39;, &#39;NumSaturatedCarbocycles&#39;, &#39;NumSaturatedHeterocycles&#39;, &#39;NumSaturatedRings&#39;, &#39;RingCount&#39;, &#39;MolLogP&#39;, &#39;MolMR&#39;, &#39;fr_Al_COO&#39;, &#39;fr_Al_OH&#39;, &#39;fr_Al_OH_noTert&#39;, &#39;fr_ArN&#39;, &#39;fr_Ar_COO&#39;, &#39;fr_Ar_N&#39;, &#39;fr_Ar_NH&#39;, &#39;fr_Ar_OH&#39;, &#39;fr_COO&#39;, &#39;fr_COO2&#39;, &#39;fr_C_O&#39;, &#39;fr_C_O_noCOO&#39;, &#39;fr_C_S&#39;, &#39;fr_HOCCN&#39;, &#39;fr_Imine&#39;, &#39;fr_NH0&#39;, &#39;fr_NH1&#39;, &#39;fr_NH2&#39;, &#39;fr_N_O&#39;, &#39;fr_Ndealkylation1&#39;, &#39;fr_Ndealkylation2&#39;, &#39;fr_Nhpyrrole&#39;, &#39;fr_SH&#39;, &#39;fr_aldehyde&#39;, &#39;fr_alkyl_carbamate&#39;, &#39;fr_alkyl_halide&#39;, &#39;fr_allylic_oxid&#39;, &#39;fr_amide&#39;, &#39;fr_amidine&#39;, &#39;fr_aniline&#39;, &#39;fr_aryl_methyl&#39;, &#39;fr_azide&#39;, &#39;fr_azo&#39;, &#39;fr_barbitur&#39;, &#39;fr_benzene&#39;, &#39;fr_benzodiazepine&#39;, &#39;fr_bicyclic&#39;, &#39;fr_diazo&#39;, &#39;fr_dihydropyridine&#39;, &#39;fr_epoxide&#39;, &#39;fr_ester&#39;, &#39;fr_ether&#39;, &#39;fr_furan&#39;, &#39;fr_guanido&#39;, &#39;fr_halogen&#39;, &#39;fr_hdrzine&#39;, &#39;fr_hdrzone&#39;, &#39;fr_imidazole&#39;, &#39;fr_imide&#39;, &#39;fr_isocyan&#39;, &#39;fr_isothiocyan&#39;, &#39;fr_ketone&#39;, &#39;fr_ketone_Topliss&#39;, &#39;fr_lactam&#39;, &#39;fr_lactone&#39;, &#39;fr_methoxy&#39;, &#39;fr_morpholine&#39;, &#39;fr_nitrile&#39;, &#39;fr_nitro&#39;, &#39;fr_nitro_arom&#39;, &#39;fr_nitro_arom_nonortho&#39;, &#39;fr_nitroso&#39;, &#39;fr_oxazole&#39;, &#39;fr_oxime&#39;, &#39;fr_para_hydroxylation&#39;, &#39;fr_phenol&#39;, &#39;fr_phenol_noOrthoHbond&#39;, &#39;fr_phos_acid&#39;, &#39;fr_phos_ester&#39;, &#39;fr_piperdine&#39;, &#39;fr_piperzine&#39;, &#39;fr_priamide&#39;, &#39;fr_prisulfonamd&#39;, &#39;fr_pyridine&#39;, &#39;fr_quatN&#39;, &#39;fr_sulfide&#39;, &#39;fr_sulfonamd&#39;, &#39;fr_sulfone&#39;, &#39;fr_term_acetylene&#39;, &#39;fr_tetrazole&#39;, &#39;fr_thiazole&#39;, &#39;fr_thiocyan&#39;, &#39;fr_thiophene&#39;, &#39;fr_unbrch_alkane&#39;, &#39;fr_urea&#39;] . . from rdkit.ML.Descriptors import MoleculeDescriptors calc = MoleculeDescriptors.MolecularDescriptorCalculator(desc_list) rdkit_desc = [calc.CalcDescriptors(m) for m in mols] print(len(rdkit_desc[0])) print(rdkit_desc[0]) . 208 (10.253328884035504, -1.7016049382716052, 10.253328884035504, 0.48660209297610124, 0.21751778620947723, 457.4320000000001, 430.2160000000003, 457.15841068399993, 178, 0, 0.1882658561787514, -0.3935665150995826, 0.3935665150995826, 0.1882658561787514, 0.8125, 1.375, 1.96875, 16.732837958750743, 9.980560326593041, 2.4752382296424567, -2.4250918642238615, 2.28493545052844, -2.6139256091055985, 5.216692900751268, -0.3337292050602669, 1.6549374848621088, 759.6629378441627, 23.41348460451408, 16.86251979526223, 16.86251979526223, 15.277294663077212, 9.99881597892019, 9.99881597892019, 7.601218129882768, 7.601218129882768, 5.431494058773282, 5.431494058773282, 3.5069302432183513, 3.5069302432183513, -1.73, 12121197.595769433, 24.90347401250815, 10.926355847078131, 5.251706120285141, 182.9353272788593, 54.693143579085124, 48.83173110198641, 18.684019846418728, 0.0, 0.0, 0.0, 0.0, 0.0, 5.261891554738487, 0.0, 30.33183534230805, 5.563451491696996, 0.0, 19.28298524181811, 54.693143579085124, 0.0, 5.261891554738487, 0.0, 0.0, 67.51575094840514, 13.213763929025836, 35.89528683400505, 0.0, 6.069221312792274, 0.0, 0.0, 0.0, 0.0, 110.37124025356763, 18.947451815200196, 11.33111286753076, 11.6674178794453, 30.33183534230805, 0.0, 0.0, 0.0, 202.32, 80.72951487743097, 41.00758331862342, 0.0, 0.0, 5.563451491696996, 0.0, 0.0, 30.33183534230805, 6.069221312792274, 0.0, 18.947451815200196, 21.59235497971106, 0.0, 0.0, 79.05525356967499, 0.48660209297610124, 0.0, 10.315179555141746, -16.47644309455915, -1.1396137696114104, 0.0, 0.65, 32, 7, 12, 0, 2, 2, 1, 0, 1, 12, 7, 12, 7, 0, 2, 2, 3, -3.108019999999997, 102.28160000000001, 0, 7, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) . . In total, we got 208 descriptors. There are two major categories: (1) physicochemical properties and (2) Fraction of a substructure (e.g., &#39;fr_Al_COO&#39;). For most of the molecules, you will get a lot zeros for the 2nd category descriptors. The following code will only compute the 1st category descriptors. . phc_desc = [i for i in desc_list if not i.startswith(&#39;fr_&#39;)] len(phc_desc) print(phc_desc) . [&#39;MaxEStateIndex&#39;, &#39;MinEStateIndex&#39;, &#39;MaxAbsEStateIndex&#39;, &#39;MinAbsEStateIndex&#39;, &#39;qed&#39;, &#39;MolWt&#39;, &#39;HeavyAtomMolWt&#39;, &#39;ExactMolWt&#39;, &#39;NumValenceElectrons&#39;, &#39;NumRadicalElectrons&#39;, &#39;MaxPartialCharge&#39;, &#39;MinPartialCharge&#39;, &#39;MaxAbsPartialCharge&#39;, &#39;MinAbsPartialCharge&#39;, &#39;FpDensityMorgan1&#39;, &#39;FpDensityMorgan2&#39;, &#39;FpDensityMorgan3&#39;, &#39;BCUT2D_MWHI&#39;, &#39;BCUT2D_MWLOW&#39;, &#39;BCUT2D_CHGHI&#39;, &#39;BCUT2D_CHGLO&#39;, &#39;BCUT2D_LOGPHI&#39;, &#39;BCUT2D_LOGPLOW&#39;, &#39;BCUT2D_MRHI&#39;, &#39;BCUT2D_MRLOW&#39;, &#39;BalabanJ&#39;, &#39;BertzCT&#39;, &#39;Chi0&#39;, &#39;Chi0n&#39;, &#39;Chi0v&#39;, &#39;Chi1&#39;, &#39;Chi1n&#39;, &#39;Chi1v&#39;, &#39;Chi2n&#39;, &#39;Chi2v&#39;, &#39;Chi3n&#39;, &#39;Chi3v&#39;, &#39;Chi4n&#39;, &#39;Chi4v&#39;, &#39;HallKierAlpha&#39;, &#39;Ipc&#39;, &#39;Kappa1&#39;, &#39;Kappa2&#39;, &#39;Kappa3&#39;, &#39;LabuteASA&#39;, &#39;PEOE_VSA1&#39;, &#39;PEOE_VSA10&#39;, &#39;PEOE_VSA11&#39;, &#39;PEOE_VSA12&#39;, &#39;PEOE_VSA13&#39;, &#39;PEOE_VSA14&#39;, &#39;PEOE_VSA2&#39;, &#39;PEOE_VSA3&#39;, &#39;PEOE_VSA4&#39;, &#39;PEOE_VSA5&#39;, &#39;PEOE_VSA6&#39;, &#39;PEOE_VSA7&#39;, &#39;PEOE_VSA8&#39;, &#39;PEOE_VSA9&#39;, &#39;SMR_VSA1&#39;, &#39;SMR_VSA10&#39;, &#39;SMR_VSA2&#39;, &#39;SMR_VSA3&#39;, &#39;SMR_VSA4&#39;, &#39;SMR_VSA5&#39;, &#39;SMR_VSA6&#39;, &#39;SMR_VSA7&#39;, &#39;SMR_VSA8&#39;, &#39;SMR_VSA9&#39;, &#39;SlogP_VSA1&#39;, &#39;SlogP_VSA10&#39;, &#39;SlogP_VSA11&#39;, &#39;SlogP_VSA12&#39;, &#39;SlogP_VSA2&#39;, &#39;SlogP_VSA3&#39;, &#39;SlogP_VSA4&#39;, &#39;SlogP_VSA5&#39;, &#39;SlogP_VSA6&#39;, &#39;SlogP_VSA7&#39;, &#39;SlogP_VSA8&#39;, &#39;SlogP_VSA9&#39;, &#39;TPSA&#39;, &#39;EState_VSA1&#39;, &#39;EState_VSA10&#39;, &#39;EState_VSA11&#39;, &#39;EState_VSA2&#39;, &#39;EState_VSA3&#39;, &#39;EState_VSA4&#39;, &#39;EState_VSA5&#39;, &#39;EState_VSA6&#39;, &#39;EState_VSA7&#39;, &#39;EState_VSA8&#39;, &#39;EState_VSA9&#39;, &#39;VSA_EState1&#39;, &#39;VSA_EState10&#39;, &#39;VSA_EState2&#39;, &#39;VSA_EState3&#39;, &#39;VSA_EState4&#39;, &#39;VSA_EState5&#39;, &#39;VSA_EState6&#39;, &#39;VSA_EState7&#39;, &#39;VSA_EState8&#39;, &#39;VSA_EState9&#39;, &#39;FractionCSP3&#39;, &#39;HeavyAtomCount&#39;, &#39;NHOHCount&#39;, &#39;NOCount&#39;, &#39;NumAliphaticCarbocycles&#39;, &#39;NumAliphaticHeterocycles&#39;, &#39;NumAliphaticRings&#39;, &#39;NumAromaticCarbocycles&#39;, &#39;NumAromaticHeterocycles&#39;, &#39;NumAromaticRings&#39;, &#39;NumHAcceptors&#39;, &#39;NumHDonors&#39;, &#39;NumHeteroatoms&#39;, &#39;NumRotatableBonds&#39;, &#39;NumSaturatedCarbocycles&#39;, &#39;NumSaturatedHeterocycles&#39;, &#39;NumSaturatedRings&#39;, &#39;RingCount&#39;, &#39;MolLogP&#39;, &#39;MolMR&#39;] . . calc = MoleculeDescriptors.MolecularDescriptorCalculator(phc_desc) rdkit_desc_sub = [calc.CalcDescriptors(m) for m in mols] print(len(rdkit_desc_sub[0])) print(rdkit_desc_sub[0]) . 123 (10.253328884035504, -1.7016049382716052, 10.253328884035504, 0.48660209297610124, 0.21751778620947723, 457.4320000000001, 430.2160000000003, 457.15841068399993, 178, 0, 0.1882658561787514, -0.3935665150995826, 0.3935665150995826, 0.1882658561787514, 0.8125, 1.375, 1.96875, 16.732837958750743, 9.980560326593041, 2.4752382296424567, -2.4250918642238615, 2.28493545052844, -2.6139256091055985, 5.216692900751268, -0.3337292050602669, 1.6549374848621088, 759.6629378441627, 23.41348460451408, 16.86251979526223, 16.86251979526223, 15.277294663077212, 9.99881597892019, 9.99881597892019, 7.601218129882768, 7.601218129882768, 5.431494058773282, 5.431494058773282, 3.5069302432183513, 3.5069302432183513, -1.73, 12121197.595769433, 24.90347401250815, 10.926355847078131, 5.251706120285141, 182.9353272788593, 54.693143579085124, 48.83173110198641, 18.684019846418728, 0.0, 0.0, 0.0, 0.0, 0.0, 5.261891554738487, 0.0, 30.33183534230805, 5.563451491696996, 0.0, 19.28298524181811, 54.693143579085124, 0.0, 5.261891554738487, 0.0, 0.0, 67.51575094840514, 13.213763929025836, 35.89528683400505, 0.0, 6.069221312792274, 0.0, 0.0, 0.0, 0.0, 110.37124025356763, 18.947451815200196, 11.33111286753076, 11.6674178794453, 30.33183534230805, 0.0, 0.0, 0.0, 202.32, 80.72951487743097, 41.00758331862342, 0.0, 0.0, 5.563451491696996, 0.0, 0.0, 30.33183534230805, 6.069221312792274, 0.0, 18.947451815200196, 21.59235497971106, 0.0, 0.0, 79.05525356967499, 0.48660209297610124, 0.0, 10.315179555141746, -16.47644309455915, -1.1396137696114104, 0.0, 0.65, 32, 7, 12, 0, 2, 2, 1, 0, 1, 12, 7, 12, 7, 0, 2, 2, 3, -3.108019999999997, 102.28160000000001) . . Similarity Search . Compute the similarity of a reference molecule and a list of molecules. Here is an example of using ECFP4 fingerprint to compute the Tanimoto Similarity (the default metric of DataStructs.FingerprintSimilarity. . chemfp is a set of command-line tools and a Python library for fingerprint generation and high-performance similarity search. . compute fingerprints | ref_smiles = &#39;COC(=O)c1c[nH]c2cc(OC(C)C)c(OC(C)C)cc2c1=O&#39; ref_mol = Chem.MolFromSmiles(ref_smiles) ref_ECFP4_fps = AllChem.GetMorganFingerprintAsBitVect(ref_mol,2) . ref_mol . bulk_ECFP4_fps = [AllChem.GetMorganFingerprintAsBitVect(x,2) for x in esol_data[&#39;ROMol&#39;]] . from rdkit import DataStructs similarity_efcp4 = [DataStructs.FingerprintSimilarity(ref_ECFP4_fps,x) for x in bulk_ECFP4_fps] . We can also add the similarity_efcp4 to the dataframe and visualize the structure and similarity. . esol_data[&#39;Tanimoto_Similarity (ECFP4)&#39;] = similarity_efcp4 PandasTools.FrameToGridImage(esol_data.head(8), legendsCol=&quot;Tanimoto_Similarity (ECFP4)&quot;, molsPerRow=4) . Sort the result from highest to lowest. . esol_data = esol_data.sort_values([&#39;Tanimoto_Similarity (ECFP4)&#39;], ascending=False) PandasTools.FrameToGridImage(esol_data.head(8), legendsCol=&quot;Tanimoto_Similarity (ECFP4)&quot;, molsPerRow=4) . Substructure Search . Native Method . This method is suitable for search substructures in a small dataset. The query substructure can be built from either SMILES or SMARTS. But the semantics of them are not exactly equivalent. In practice, SMARTS is more commonly used. SMARTS allows complex atom and bond expressions. . m = Chem.MolFromSmiles(&#39;c1ccccc1O&#39;) patt = Chem.MolFromSmarts(&#39;ccO&#39;) m.HasSubstructMatch(patt) . True . Here is an exmaple to find the matched molecules from a dataset. . patt = Chem.MolFromSmarts(&#39;c1ccncn1&#39;) patt . matches = [m for m in esol_data[&#39;ROMol&#39;] if m.HasSubstructMatch(patt)] print(f&#39;There are {len(matches)} matched molecules&#39;) matches[0] . There are 48 matched molecules . SubstructLibrary . A reading list for this topics: . Introducing the SubstructLibrary | A couple of substructure search topics | The secrets of fast SMARTS matching | . MCS . from rdkit.Chem import rdFMCS smiles = [ &#39;N#CC(OC1OC(COC2OC(CO)C(O)C(O)C2O)C(O)C(O)C1O)c1ccccc1&#39;, &#39;c1ccc2c(c1)ccc1c2ccc2c3ccccc3ccc21&#39;, &#39;C=C(C)C1Cc2c(ccc3c2OC2COc4cc(OC)c(OC)cc4C2C3=O)O1&#39;, &#39;ClC(Cl)=C(c1ccc(Cl)cc1)c1ccc(Cl)cc1&#39; ] mols = [Chem.MolFromSmiles(smi) for smi in smiles] res = rdFMCS.FindMCS(mols) res.smartsString . &#39;[#6](-,:[#6]1:[#6]:[#6]:[#6]:[#6]:[#6]:1)-,:[#6]&#39; . res_mol = Chem.MolFromSmarts(res.smartsString) res_mol . Highlight the MCS in molecules. . highlight_mcs = [mMol.GetSubstructMatch(res_mol) for mMol in mols] Draw.MolsToGridImage(mols, highlightAtomLists = highlight_mcs, subImgSize=(250,250), useSVG=False, molsPerRow=4) . Molecular Transformations . Molecular Decomposition . More Reading . Offical documentation. | Getting Started with the RDKit in Python | The RDKit Book | RDKit CookbookThis document provides example recipes of how to carry out particular tasks using the RDKit functionality from Python. The contents have been contributed by the RDKit community, tested with the latest RDKit release, and then compiled into this document. . |",
            "url": "https://xinhaoli74.github.io/blog/rdkit/2021/01/06/rdkit.html",
            "relUrl": "/rdkit/2021/01/06/rdkit.html",
            "date": " • Jan 6, 2021"
        }
        
    
  
    
  
    
  

  
  

  
      ,"page1": {
          "title": "📓 Code Snippets",
          "content": "A personal collection of reusable code snippets. . Tag Description Colab . rdkit | Generating Descriptors using RDKit | | . huggingface | Training molecular language models with Huggingface library | | .",
          "url": "https://xinhaoli74.github.io/blog/code/",
          "relUrl": "/code/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
      ,"page7": {
          "title": "㊙️ About Me",
          "content": "I like to write about basic cheminformatics concepts and play with different ML/DL algorithms and cheminformatics tools. You could connect with me on LinkedIn and Twitter. .",
          "url": "https://xinhaoli74.github.io/blog/z_about/",
          "relUrl": "/z_about/",
          "date": ""
      }
      
  

  
  

  
  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://xinhaoli74.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}